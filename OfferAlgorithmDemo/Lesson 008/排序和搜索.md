# 排序算法

## 题目：用Swift实现归并排序、快速排序。

常用的排序算法一般就以下7种：

|   名称   | 时间复杂度 | 空间复杂度 | 是否稳定 |
| :------: | :--------: | :--------: | :------: |
| 冒泡排序 |   O(n²)    |    O(1)    |    是    |
| 插入排序 |   O(n²)    |    O(1)    |    是    |
| 选择排序 |   O(n²)    |    O(1)    |    否    |
|  堆排序  |  O(nlogn)  |    O(1)    |    否    |
| 归并排序 |  O(nlogn)  |    O(n)    |    是    |
| 快速排序 |  O(nlogn)  |  O(logn)   |    否    |
|  桶排序  |    O(n)    |    O(k)    |    是    |

一般情况下，好的排序算法性能是O(nlogn)，坏的排序算法性能是O(n²)。

## 桶排序

将输入的数组分配到一定数量的空桶中，每个空桶再单独排序。当输入的数组是均匀分配时，桶排序的时间复杂度为O(n)。

### 微软面试题：有红球、黄球、篮球若干个，要求将所有红球放在黄球的前面，最后放上所有的篮球。

这道题最直接的解法就是用桶排序。首先第一此遍历，统计有多少个红球（假设为x个），多少个黄球（假设为y个）和多少个篮球（假设为z个）。然后再一次遍历，数组前x个位置放红球，中间y个位置放对应数量的黄球，最后z个位置再放上篮球。

另外，**稳定**的意思：即相等的键值。如果排序后的次序与原来未排序的次序相同，则称此排序算法为稳定的。

在Swift中，排序的使用方式如下：

```swift
/// 以升序排序为例，原数组可改变
array.sort()

/// 以降序排列为例，原数组不可改变
newArray = array.sorted(by: >)

/// 字典键值排序示例
let keys = Array(map.keys)
let sortedKeys = keys.sorted() {
	return map[$0]!> map[$1]!
}
```

在Java中，其自带的sort函数部分是用归并排序实现的。而在Swift源代码中，sort函数采用的是一种内省算法（IntroSort）。它由堆排序、插入排序、快速排序3种算法构成，依据输入的深入选择最佳的算法来完成。