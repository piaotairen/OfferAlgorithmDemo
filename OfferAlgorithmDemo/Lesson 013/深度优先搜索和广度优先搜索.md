# 深度优先搜索和广度优先搜索

二分搜索的算法复杂度只有O(logn)，但使用起来有局限性：只有在输入数组是排序的情况下才能使用。下面介绍两种更复杂的搜索算法——深度优先搜索（Depth First Search,DFS）和广度优先搜索(Breadth First Search,BFS)。

例如在家里找钥匙，有两种选择：

（1）从当前角落开始，顺着一个方向不停找。这个方向搜索完毕，回到角落，从另一个方向寻找。这就是DFS。

（2）从当前角落开始，每次把距离最近的所有方向的角落都搜索一遍，直到找到钥匙或所有的方向都搜索完毕为止。这就是BFS。

二叉树中的前序遍历的本质是DFS，二叉树的层级遍历的本质是BFS。

### 题目：DFS、BFS在Swift中的实现。

### 题目：给定一个字母矩阵，可以从任意一个字母开始，从任意方向，选择任意长度，选出其中所有的单词。

简化：假如字母矩阵中搜索一个单词"crowd"，改怎么做？

思路：先找到"c"这个字母所在位置，然后从上下左右四个方向找第二个字母，接着找第三个字母，直到全部找到。如果没有找到，就回到首字母"c"所在的另一个位置重新搜索。

注意的细节：不能回头重复搜索字母。比如已经从"c"开始向上搜索到"r"了，这个时候就不能从"r"向下搜索，因为"c"已经访问过了。

### 拓展：给定一个字母矩阵，搜索多个单词（字典）呢？

思路：暴力做法就是在矩阵中搜索字典中的所有的单词，这种做法的总复杂度为O(mn²)，其中m为字典中单词的数量，n为矩阵的边长。

这时就要引入Trie树（前缀树）。前缀树是一种有序树，用于保存关联数组，特别适用于保存字符串。首先把字典转化为前缀树，这样的好处在于它可以检测矩阵中字母构成的前缀是不是一个单词的前缀，如果不是，就没必要继续搜索了。这样就把搜索字典中的所有单词的操作，转换为只搜索字母矩阵操作。